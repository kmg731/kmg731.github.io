I"”L<p>‚Äî
layout: post
title:  ‚ÄúVigenere Cypher in C‚Äù
‚Äî</p>

<h1 id="introduction">Introduction</h1>

<p><a href="https://github.com/kmg731/vignereCipher">Original Project in Python</a>
<a href="https://github.com/kmg731/Vigenere-in-C">GitHub Repo for this project</a></p>

<p>About a year ago, I built a little python tool to encrypt and decrypt small messages using the Vigenere cypher.<br />
It worked out without any errors and was a pretty small program overall (only about 50 lines of code).  Since it
was a fun and interesting project, I‚Äôve decided to rework it as a CLI applicaton written in C.  I‚Äôve never made a 
straight CLI application, but hey, how hard could it be?  Prepare for an overly verbose article about something
that‚Äôs probably pretty simple.  But hey, laugh at the places where I got stuck if you want.</p>

<p>If you‚Äôre unfamiliar with the Vigenere cipher, it is essentially an extension of the Caesar cipher.  In the Caesar 
cipher, each letter in a word is shifted up or down the alphabet by a fixed number.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ABCDEFGHIJKLMNOPQRSTUVWXYZ  - Normal alphabet, no shift
FGHIJKLMNOPQRSTUVWXYZABCDE  - Caesar cipher, shift = 5
</code></pre></div></div>

<p>Say, for example, I wanted to 
encrypt the word ‚ÄúTOAD‚Äù using the Caesar cipher.  I would first select a shift value (let‚Äôs use 5) and then select 
the letter 5 after the original letter.  Thus, ‚ÄúTOAD‚Äù would now become ‚ÄúYTFI.‚Äù  The Caesar cipher is a bit simple.<br />
We can do better.</p>

<p>The Vigenere cipher uses the letters of a keyword to encrypt each letter of the main message.  If, for example, I want
to use the Vigenere cipher on the word ‚ÄúTOAD,‚Äù I would first select a keyword to use in the encryption, let‚Äôs go with
‚ÄúFROG‚Äù for this one.</p>

<ul>
  <li>First, you encrypt the first letter of ‚ÄúTOAD‚Äù using ‚ÄúF‚Äù as the shift value.  You get: Y</li>
  <li>Next, do the same to ‚ÄúO‚Äù using ‚ÄúR‚Äù.  you get: F</li>
  <li>Repeat for ‚ÄúA,‚Äù using ‚ÄúO‚Äù: O</li>
  <li>Finish with ‚ÄúD‚Äù and ‚ÄúG‚Äù: J</li>
</ul>

<p>The final encryption for ‚ÄúTOAD‚Äù using ‚ÄúFROG‚Äù as the key value is now ‚ÄúYFOJ‚Äù instead of ‚ÄúYTFI.‚Äù
This is harder and less obvious to crack than the regular Caesar Cipher.  It is also not very hard to see how easy it
can be to implement this with code.</p>

<h1 id="the-code-part">The Code Part</h1>

<p>The Caesar cipher is quite easy to implement in code.  One nice feature of C is that chars can be evaluated as ints. 
As far as I know, the only way to use this int/char feature in Python is to use <code class="language-plaintext highlighter-rouge">ord()</code> and <code class="language-plaintext highlighter-rouge">chr()</code>.  This always felt
a bit cumbersome, so it‚Äôs nice to be a bit more direct when modifying characters with numbers.</p>

<p>Along with directly porting the funtcionality of the original Python program to an easier command line program, I‚Äôd
also like to add in some new functionality, mainly that of being able to encrypt an entire .txt file.  I‚Äôll have to 
play around and see how the command line handles files as arguments.</p>

<h2 id="structure">Structure</h2>

<p>The first thing to think about is how I want the program to handle the encrypting.  I think the most straightforward
structure is to first create two functions for a Caesar cipher
and then write two more wrapper functions which give the Vigenere cypher.  I can also <code class="language-plaintext highlighter-rouge">inline</code> the original
Caesar encrypt/decrypt to make the process a bit faster.</p>

<p>The string will also have to go through some kind of formatting funtion if we want this to scale up to full documents.
This means that, unfortunately, spaces and punctuation will have to be removed and the entire message will be output as
one single line of characters.  I can‚Äôt really imagine some way to easily add the spaces back in without this ballooning
to something massive, so I‚Äôll leave it out.</p>

<h2 id="functions">Functions</h2>

<p>NOTE: I ran into a few bugs at this point.  I‚Äôll cover them in the Bugs section.  The code going forward will be 
correct and with the bugs fixed.</p>

<p>So, how do we actually implement the Caesar encrypt/decrypt in C?  Thinking about all the addition and subtraction
can be a bit weird so I‚Äôll try to walk through it as best I can.</p>

<p>The formula for adding the shift to a character while also keeping it in the correct range is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(((char + shift - 97) % 26) + 97)
</code></pre></div></div>

<p>This first takes the numeric value of the char, adds the shift and then subtracts it from 97 (97 being the ascii
code for ‚Äòa‚Äô.  We could have just as easily written <code class="language-plaintext highlighter-rouge">char</code> + shift - ‚Äòa‚Äô).  This will give us the position of the 
letter in the alphabet.  We perform modulus division on that number so it won‚Äôt be out of range, and then add back
‚Äòa‚Äô to it to get the proper ascii character.</p>

<p>One thing that didn‚Äôt occur to me immediately was what parameters the Caesar encrypt/decrypt should take.<br />
Originally, it made the most sense to use <code class="language-plaintext highlighter-rouge">char*</code>, since 
the cipher is meant to take strings and encode or decode them.  Though, after thinking about it for a bit, it makes
more sense that they would take only <code class="language-plaintext highlighter-rouge">char</code>, since the main use will be to encrypt or decrypt a single <code class="language-plaintext highlighter-rouge">char</code> within
the wrapper function.  This should also increase speed since there is now no use for any loops and can be done with
just some simple arithmetic. We can also remove the function call to <code class="language-plaintext highlighter-rouge">strlen()</code> too.  Our function originally
went from:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static inline void
caesarEncode(char* message, int shift)
{
  int len = strlen(message);

  for (int i = 0; i &lt; len; ++i){
    message[i] = (((message[i] + shift - 97) % 26) + 97);
  }

  return message;
}
</code></pre></div></div>

<p>to now only being:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static inline char
caesarEncode(char message, int shift)
{
  return (((message + shift - 97) % 26) + 97);
}
</code></pre></div></div>

<p>Obviously if we wanted to add functionality for specifically Caesar ciphers, we wouldn‚Äôt be able to do this, but since
this is only a wrapper function to be used within another function, there is no reason to make it more complicated than
it has to be.  Since this function will be called so many times, it also should be as simple as possible.  Since this is 
very simple, we‚Äôre also able to add <code class="language-plaintext highlighter-rouge">inline</code> to get it to run a bit faster too. <code class="language-plaintext highlighter-rouge">inline</code> will remove the funciton call 
overhead.</p>

<p>Now, like I originally thought, you might be thinking that the <code class="language-plaintext highlighter-rouge">caesarDecode()</code> function wil be just as easy to write as 
<code class="language-plaintext highlighter-rouge">caesarEncode()</code>.  You‚Äôre not entirely wrong, but there is one thing I overlooked that caused me a lot of pain when trying
to debug this.<br />
When I first wrote this program in Python, it never really occurred to me that if a letter wraps around the alphabet (let‚Äôs 
say your message is just ‚Äòa‚Äô with the decode key ‚Äòb‚Äô), the modulo will break the function and not properly ‚Äúwrap‚Äù everything
nicely around 26.  C and Python handle Modulo division differenly in regards to negative numbers.  In Python, a negative input
in a modulo equation is handled like this: x % n = z, where 0 &lt;= z &lt;= n.  This means that -1 % 26 = 25, not -1.</p>

<p>In C however, modulo is just modulo.  There‚Äôs no fancy wraparound functionality and -1 % 26 is just -1.  This causes problems 
for the cipher since we need it to wrap around the alphabet.  ‚Äòa‚Äô - 1 needs to be ‚Äòz‚Äô.  It took awhile to figure this out both
in Python and in C, but the solution was simply to add my own function called <code class="language-plaintext highlighter-rouge">modWrap()</code> which solves the problem.<br />
Here‚Äôs the function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int
wrapMod(int a, int b)
{
  if (a &gt;= 0){
    return (a % b)
  } else {
    return (a % b + b) % b;
  }
}
</code></pre></div></div>

<p>This is more verbose than it has to be though using the ternary operator here only makes it more difficult to read
than it should be.</p>

<p>This little detour was all to explain that we need to change the way we handle the <code class="language-plaintext highlighter-rouge">caesarDecode()</code> function, since 
we‚Äôre dealing with subtraction.  Put together, we get this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static inline char
caesarDecode(char message, int shift)
{
  return wrapMod((message - shift - 97), 26) + 97;
}
</code></pre></div></div>

<h2 id="the-vigenere-functions">The Vigenere functions</h2>

<p>Now on to the actual Vigenere cipher wrapper functions. It shouldn‚Äôt be too hard to implement now that we‚Äôve got everything
set up to process the message.  Let‚Äôs first break down the steps for what should happen to a single character.</p>

<p>The main <code class="language-plaintext highlighter-rouge">encode()</code> function should contain a loop which calls <code class="language-plaintext highlighter-rouge">caesarEncode()</code> on each letter with each key from the 
larger passed string.  It‚Äôs not very hard to keep the key value in the correct range for any lenght of message or key, 
just use <code class="language-plaintext highlighter-rouge">key[i % keyLen]</code>.  Also, don‚Äôt forget to add <code class="language-plaintext highlighter-rouge">- 'a'</code> so the correct shift value is applied instead of the ASCII
value of the character (I made this mistake and spent a bit trying to figure out what was going wrong).  Adding it right to
the <code class="language-plaintext highlighter-rouge">key[]</code> value saves some time and keeps us from having to add something like <code class="language-plaintext highlighter-rouge">shift -=</code> 97= at the start of both
<code class="language-plaintext highlighter-rouge">caesarEncode()</code> and <code class="language-plaintext highlighter-rouge">caesarDecode()</code>.</p>

<p>This is what I came up with for the main encode/decode functions:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char*
encode(char* message, char* key)
{
  int msgLen = strLen(message);
  int keyLen = strlen(key);

  for (int i = 0; i &lt; msgLen; ++i){
    message[i] = caesarEncode(message[i], key[i % keyLen] - 'a');
  }

  return message;
}
</code></pre></div></div>

<p>I chose to declare <code class="language-plaintext highlighter-rouge">msgLen</code> and <code class="language-plaintext highlighter-rouge">keyLen</code> rather than using the clunkier (and probably slower) <code class="language-plaintext highlighter-rouge">strlen(var)</code> method, so
<code class="language-plaintext highlighter-rouge">strlen()</code> is only called once, rather than once per iteration.  The <code class="language-plaintext highlighter-rouge">decode()</code> function is nearly identical to the 
<code class="language-plaintext highlighter-rouge">encode()</code> function, though it obviously uses <code class="language-plaintext highlighter-rouge">caesarDecode()</code> instead.</p>

<h1 id="file-io-im-probably-doing-this-wrong">File I/O: I‚Äôm probably doing this wrong</h1>

<p>The next feature that I want to add is the ability to apply this encode/decode to an entire file.  There are a few
things to plan out before doing this.  How do I want the text itself to be handled?  Should it be one long string
of text or should spaces, tabs, and newline characters be preserved?  For this version, I think I just want to make
everything one long string to be deciphered.  Despite it being less visually appealing, it‚Äôs sure harder to break
when you don‚Äôt know where the start/end of a word is.  Also, since this is a plain .txt file, I might add some 80 
character column width in there so it at least comes out as a single block of text instead of one long line of 
text.</p>

<p>I‚Äôm sure there‚Äôs a better way to handle these kinds of command line arguments, but for now, I‚Äôll just add another option
for ‚Äú-f‚Äù and a separate function to handle the file I/O.  Each relevant argv[] parameter will be passed in and the 
function can handle the rest from there.</p>

<p>I‚Äôve decided to split up the formatting and encoding/decoding functions into two separate functions.  The first one
<code class="language-plaintext highlighter-rouge">format()</code> will take in a file name and return a formatted buffer containg the contents of that file.  For now, the 
formatting just removes all spaces, but I‚Äôd like to use something that can search for a char in a string without
just looping through every char in that string.</p>

<p>For now, this is what I‚Äôve come up with:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char*
format(char* fileName)
{
        FILE *fp;
        fp = fopen(fileName, "r");

        if(fp == NULL){
                printf("Error: Could not open file\n");
                return 0;
        }

        fseek(fp, 0, SEEK_END);
        long int buffSize = ftell(fp);
        fseek(fp, 0, SEEK_SET);

        char* buffer = calloc(buffSize + 1, sizeof(char));

        if (buffer == NULL){
                printf("Error: Could not allocate buffer memory\n");
                return 0;
        }

        fread(buffer, sizeof(char), buffSize, fp);

        char* formatBuffer = calloc(buffSize + 1, sizeof(char));
        int fBufCounter = 0;

        for (int i = 0; i &lt; strlen(buffer); ++i){
                if(buffer[i] &gt;= 'a' &amp;&amp; buffer[i] =&lt; 'z'){
                        formatBuffer[fBufCounter] = buffer[i];
                        ++fBufCounter;
                }
        }

        free(buffer);
        fclose(fp);

        return formatBuffer;
}
</code></pre></div></div>

<p>This is probably the most complex part of the program (though it‚Äôs not too bad).  First the funciton figures out
how big the incoming file is and allocates a buffer big enough to hold it all.  It then reads the contents of that file
into the buffer</p>

<p>The easiest way I found to handle formatting without having to modify the original buffer was to just make a new
buffer and copy the desired characters into that, rather than trying to remove spaces from the original.  This means
we just have to keep track of our position in the new buffer and loop through the original, skipping over any characters
we don‚Äôt want.</p>

<p>Originally I was going to use a function that would find a character
in a given string, but since I only wanted lowercase a-z characters, there is no reason to make it any harder than it
has to be.  If I were to check for all characters between ‚Äòa‚Äô and ‚Äòz‚Äô there would then be no reason to check if that 
character was something in the string ‚Äú1234567890,./?&gt;&lt;‚Äù etc.  Having it only add character between ‚Äòa‚Äô and ‚Äòz‚Äô should
be alright for the majority of documents. If it becomes an issue, I‚Äôll add in something to convert uppercase letters to 
lowercase letters, but for now I think this will work just fine.  This was one case where I really wanted to use 
something but after a bit of thinking found that there‚Äôs really no benefit to using it.</p>

<p>Also don‚Äôt be like me and forget to make the formatting ranges correct.  Make sure they exclude anything outside of the 
‚Äòa‚Äô to ‚Äòz‚Äô range, not everything in that range.  Also make sure to use &gt;= and &lt;= so ‚Äòa‚Äô and ‚Äòz‚Äô are not formatted out.</p>

<p>And the actual encoding/decoding function looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int
processFile(char* fileName, char* option, char* key)
{
        FILE *newFile;
        newFile = fopen("Vigenere_Output.txt", "w");
        if (newFile == NULL){
                printf("Error: Could not open file\n");
                return -1;
        }
        char* formatBuffer = format(fileName);

        if (strcmp("encode", option) == 0){
                fputs(encode(formatBuffer, key), newFile);
        } else if (strcmp("decode", option) == 0) {
                fputs(decode(formatBuffer, key), newFile);
        }

        free(formatBuffer);
        fclose(newFile);

        return 0;
}
</code></pre></div></div>

<p>This is actually one of the more straightforward parts of the program.  The formtting was much harder with all the 
buffers.  This just opens a new file, formats the input, then encodes or decodes based off of what the user input
on the command line.  Then it frees the formatBuffer and closes the file.  The only real problem I ran into when 
working on this part was the file name.  If I entered it in as a raw string of text, it worked fine.  As soon as 
I started putting in variables or function returns into there, it would break and not open the file.</p>

<p><span class="underline">Example</span>: If I used <code class="language-plaintext highlighter-rouge">fopen(strcat(option, fileName), "w"))</code> the file would not open and the program would exit without
notice.  If I instead used what is shown <code class="language-plaintext highlighter-rouge">fopen("Vigenere_Output.txt", "w")</code> it will work fine with no problem. 
I‚Äôm not exactly sure how to fix this as of right now, or why it‚Äôs doing this, but this seems like an alright work around
for the time being.  If it needs to be fixed in the future, I will but it‚Äôs not that big of a deal if it stays like this.</p>

<h1 id="conclusion">Conclusion</h1>

<p>This was a fun project and a nice introduction to writing out my thought process as I‚Äôm programming. I think it helped
to push me to do things that I might not be completely familiar with and try new things.  If there‚Äôs something I don‚Äôt
understand, I can try writing it out here to teach myself along with anyone reading.  It also helps me look more 
critically at what I‚Äôm writing.  For this project especially, having to go line-by-line and explain why I did something
or how it works really helped me to consider everything I wrote and why I was writing it.</p>

<p>For the project, it was easier than I‚Äôd thought.  I remember first making this in Python and thinking that it was all
complex string manipulation and crazy modulo division.  Redoing it in C showed me that it‚Äôs really not that hard at all
and, in fact, my original code was more complex than it had to be (Maybe I should go back and update that original 
repo so it‚Äôs actually readable).</p>

<p>Overall, I enjoyed this project.  It didn‚Äôt take very long, there were no real major bugs and for the most part it was 
pretty smooth sailing.</p>

:ET