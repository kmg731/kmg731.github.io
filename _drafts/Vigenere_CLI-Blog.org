---
layout: post
title:  "Vigenere Cypher in C"
---

* Introduction


[[https://github.com/kmg731/vignereCipher][Original Project in Python]]

About a year ago, I built a little python tool to encrypt and decrypt small messages using the Vigenere cypher.  
It worked out without any errors and was a pretty small program overall (only about 50 lines of code).  Since it
was a fun and interesting project, I've decided to rework it as a CLI applicaton written in C.  I've never made a 
straight CLI application, but hey, how hard could it be?  Prepare for an overly verbose article about something
that's probably pretty simple.  But hey, laugh at the places where I got stuck if you want.  

If you're unfamiliar with the Vigenere cipher, it is essentially an extension of the Caesar cipher.  In the Caesar 
cipher, each letter in a word is shifted up or down the alphabet by a fixed number.  

#+BEGIN_SRC
ABCDEFGHIJKLMNOPQRSTUVWXYZ  - Normal alphabet, no shift
FGHIJKLMNOPQRSTUVWXYZABCDE  - Caesar cipher, shift = 5
#+END_SRC

Say, for example, I wanted to 
encrypt the word "TOAD" using the Caesar cipher.  I would first select a shift value (let's use 5) and then select 
the letter 5 after the original letter.  Thus, "TOAD" would now become "YTFI."  The Caesar cipher is a bit simple.  
We can do better.

The Vigenere cipher uses the letters of a keyword to encrypt each letter of the main message.  If, for example, I want
to use the Vigenere cipher on the word "TOAD," I would first select a keyword to use in the encryption, let's go with
"FROG" for this one.  
- First, you encrypt the first letter of "TOAD" using "F" as the shift value.  You get: Y
- Next, do the same to "O" using "R".  you get: F
- Repeat for "A," using "O": O
- Finish with "D" and "G": J

The final encryption for "TOAD" using "FROG" as the key value is now "YFOJ" instead of "YTFI."
This is harder and less obvious to crack than the regular Caesar Cipher.  It is also not very hard to see how easy it
can be to implement this with code. 

* The Code Part
The Caesar cipher is quite easy to implement in code.  One nice feature of C is that chars can be evaluated as ints. 
As far as I know, the only way to use this int/char feature in Python is to use =ord()= and =chr()=.  This always felt
a bit cumbersome, so it's nice to be a bit more direct when modifying characters with numbers.  

Along with directly porting the funtcionality of the original Python program to an easier command line program, I'd
also like to add in some new functionality, mainly that of being able to encrypt an entire .txt file.  I'll have to 
play around and see how the command line handles files as arguments.  

** Structure

The first thing to think about is how I want the program to handle the encrypting.  I think the most straightforward
structure is to first create two functions for a Caesar cipher
and then write two more wrapper functions which give the Vigenere cypher.  I can also =inline= the original
Caesar encrypt/decrypt to make the process a bit faster.  

The string will also have to go through some kind of formatting funtion if we want this to scale up to full documents.
This means that, unfortunately, spaces and punctuation will have to be removed and the entire message will be output as
one single line of characters.  I can't really imagine some way to easily add the spaces back in without this ballooning
to something massive, so I'll leave it out.

** Functions 

NOTE: I ran into a few bugs at this point.  I'll cover them in the Bugs section.  The code going forward will be 
correct and with the bugs fixed. 

So, how do we actually implement the Caesar encrypt/decrypt in C?  Thinking about all the addition and subtraction
can be a bit weird so I'll try to walk through it as best I can.

The formula for adding the shift to a character while also keeping it in the correct range is:
#+BEGIN_SRC C
(((char + shift - 97) % 26) + 97)
#+END_SRC

This first takes the numeric value of the char, adds the shift and then subtracts it from 97 (97 being the ascii
code for 'a'.  We could have just as easily written =char= + shift - 'a').  This will give us the position of the 
letter in the alphabet.  We perform modulus division on that number so it won't be out of range, and then add back
'a' to it to get the proper ascii character.  

One thing that didn't occur to me immediately was what parameters the Caesar encrypt/decrypt should take.  
Originally, it made the most sense to use =char*=, since 
the cipher is meant to take strings and encode or decode them.  Though, after thinking about it for a bit, it makes
more sense that they would take only =char=, since the main use will be to encrypt or decrypt a single =char= within
the wrapper function.  This should also increase speed since there is now no use for any loops and can be done with
just some simple arithmetic. We can also remove the function call to =strlen()= too.  Our function originally
went from:

#+BEGIN_SRC C
static inline void
caesarEncode(char* message, int shift)
{
  int len = strlen(message);

  for (int i = 0; i < len; ++i){
    message[i] = (((message[i] + shift - 97) % 26) + 97);
  }

  return message;
}
#+END_SRC

to now only being:

#+BEGIN_SRC C
static inline char
caesarEncode(char message, int shift)
{
  return (((message + shift - 97) % 26) + 97);
}
#+END_SRC

Obviously if we wanted to add functionality for specifically Caesar ciphers, we wouldn't be able to do this, but since
this is only a wrapper function to be used within another function, there is no reason to make it more complicated than
it has to be.  Since this function will be called so many times, it also should be as simple as possible.  Since this is 
very simple, we're also able to add =inline= to get it to run a bit faster too. =inline= will remove the funciton call 
overhead.  

Now, like I originally thought, you might be thinking that the =caesarDecode()= function wil be just as easy to write as 
=caesarEncode()=.  You're not entirely wrong, but there is one thing I overlooked that caused me a lot of pain when trying
to debug this.  
When I first wrote this program in Python, it never really occurred to me that if a letter wraps around the alphabet (let's 
say your message is just 'a' with the decode key 'b'), the modulo will break the function and not properly "wrap" everything
nicely around 26.  C and Python handle Modulo division differenly in regards to negative numbers.  In Python, a negative input
in a modulo equation is handled like this: x % n = z, where 0 <= z <= n.  This means that -1 % 26 = 25, not -1. 

In C however, modulo is just modulo.  There's no fancy wraparound functionality and -1 % 26 is just -1.  This causes problems 
for the cipher since we need it to wrap around the alphabet.  'a' - 1 needs to be 'z'.  It took awhile to figure this out both
in Python and in C, but the solution was simply to add my own function called =modWrap()= which solves the problem.  
Here's the function:

#+BEGIN_SRC C
int
wrapMod(int a, int b)
{
  if (a >= 0){
    return (a % b)
  } else {
    return (a % b + b) % b;
  }
}
#+END_SRC

This is more verbose than it has to be though using the ternary operator here only makes it more difficult to read
than it should be.  

This little detour was all to explain that we need to change the way we handle the =caesarDecode()= function, since 
we're dealing with subtraction.  Put together, we get this:

#+BEGIN_SRC C
static inline char
caesarDecode(char message, int shift)
{
  return wrapMod((message - shift - 97), 26) + 97;
}
#+END_SRC

** The Vigenere functions
Now on to the actual Vigenere cipher wrapper functions. It shouldn't be too hard to implement now that we've got everything
set up to process the message.  Let's first break down the steps for what should happen to a single character.

#+BEGIN_COMMENT
1. encode("abcd", "ab") -> caesarEncode('a', 'a') -> returns 'b' => move to the next char
                        -> caesarEncode('b', 'b') -> returns 'd' => move to the next char
                        -> caesarEncode('c', 'a') -> returns 'd' => move to the next char
                        -> caesarEncode('d', 'b') -> returns 'f' => move to the next char
           -> entire string is done, return message

#+END_COMMENT

The main =encode()= function should contain a loop which calls =caesarEncode()= on each letter with each key from the 
larger passed string.  It's not very hard to keep the key value in the correct range for any lenght of message or key, 
just use =key[i % keyLen]=.  Also, don't forget to add =- 'a'= so the correct shift value is applied instead of the ASCII
value of the character (I made this mistake and spent a bit trying to figure out what was going wrong).  Adding it right to
the =key[]= value saves some time and keeps us from having to add something like =shift -== 97= at the start of both
=caesarEncode()= and =caesarDecode()=.  

This is what I came up with for the main encode/decode functions:

#+BEGIN_SRC C
char*
encode(char* message, char* key)
{
  int msgLen = strLen(message);
  int keyLen = strlen(key);

  for (int i = 0; i < msgLen; ++i){
    message[i] = caesarEncode(message[i], key[i % keyLen] - 'a');
  }

  return message;
}
#+END_SRC

I chose to declare =msgLen= and =keyLen= rather than using the clunkier (and probably slower) =strlen(var)= method, so
=strlen()= is only called once, rather than once per iteration.  The =decode()= function is nearly identical to the 
=encode()= function, though it obviously uses =caesarDecode()= instead. 

* File I/O: I'm probably doing this wrong
The next feature that I want to add is the ability to apply this encode/decode to an entire file.  There are a few
things to plan out before doing this.  How do I want the text itself to be handled?  Should it be one long string
of text or should spaces, tabs, and newline characters be preserved?  For this version, I think I just want to make
everything one long string to be deciphered.  Despite it being less visually appealing, it's sure harder to break
when you don't know where the start/end of a word is.  Also, since this is a plain .txt file, I might add some 80 
character column width in there so it at least comes out as a single block of text instead of one long line of 
text.  

I'm sure there's a better way to handle these kinds of command line arguments, but for now, I'll just add another option
for "-f" and a separate function to handle the file I/O.  Each relevant argv[] parameter will be passed in and the 
function can handle the rest from there.  

I've decided to split up the formatting and encoding/decoding functions into two separate functions.  The first one
=format()= will take in a file name and return a formatted buffer containg the contents of that file.  For now, the 
formatting just removes all spaces, but I'd like to use something that can search for a char in a string without
just looping through every char in that string.  

For now, this is what I've come up with:

#+BEGIN_SRC C
char*
format(char* fileName)
{
        FILE *fp;
        fp = fopen(fileName, "r");

        if(fp == NULL){
                printf("Error: Could not open file\n");
                return 0;
        }

        fseek(fp, 0, SEEK_END);
        long int buffSize = ftell(fp);
        fseek(fp, 0, SEEK_SET);

        char* buffer = calloc(buffSize + 1, sizeof(char));

        if (buffer == NULL){
                printf("Error: Could not allocate buffer memory\n");
                return 0;
        }
        
        fread(buffer, sizeof(char), buffSize, fp);

        char* formatBuffer = calloc(buffSize + 1, sizeof(char));
        int fBufCounter = 0;

        /* This is exactly the place where I would need find(char, char*) to search for
         * a char in a string but looping through a string of n length for each char in 
         * a file buffer doesn't seem like the best idea for efficiency.
         */
      
        for (int i = 0; i < strlen(buffer); ++i){
                if (buffer[i] != ' '){
                        formatBuffer[fBufCounter] = buffer[i];
                        ++fBufCounter;
                }
        }

        free(buffer);
        fclose(fp);
        
        return formatBuffer;
}
#+END_SRC

The easiest way I found to handle formatting without having to modify the original buffer was to just make a new
buffer and copy the desired characters into that, rather than trying to remove spaces from the original.  This means
we just have to keep track of our position in the new buffer and loop through the original, skipping over any characters
we don't want. 

The actual encoding/decoding function looks like this:

#+BEGIN_SRC C
int
processFile(char* fileName, char* option, char* key)
{
        FILE *newFile;
        newFile = fopen("", "w");
        if (newFile == NULL){
                printf("Error: Could not open file\n");
                return -1;
        }
        char* formatBuffer = format(fileName);

        if (strcmp("encode", option) == 0){
                fputs(encode(formatBuffer, key), newFile);
        } else if (strcmp("decode", option) == 0) {
                fputs(decode(formatBuffer, key), newFile);
        }
        
        free(formatBuffer);
        fclose(newFile);
        
        return 0;
}
#+END_SRC

It's pretty simple.  It opens a new file with the filename "encode/decodeFilename.txt" (not the greatest but losing the
+ overload functionality with strings has maybe been the worst thing about this project), then makes a new string to
hold the formatBuffer from =format()=, encodes or decodes it based off of the option passed into it, writes it all to
the file and then finally frees the formatBuffer memory and closes the file.  

* Bugs
** Major
There was one massive oversight that occurred when making this project.  I didn't realize that Python (the sneaky 
bastard) wraps negative numbers around when doing modulo division.  This means that the result of -1 % 26 is 25.
In C however, -1 % 26 is just -1.  

The fix for this wasn't very hard, but it was a frustrating bug to wrestle with.  I solved the problem by adding 
my own function I called =wrapMod()= (I know I could have been cheeky using the ? operator, but let's try and
keep things readable):

#+BEGIN_SRC C
int
wrapMod(int a, int b)
{
  if (a >= 0){
    return (a % b);
  } else {
    return (a % b + b) % b;
  }
}
#+END_SRC

** Minor
One small oversight was that I forgot to subtract 'a' from the shift value, which gave a lot of weird results.  Instead 
of a shift value being 3, it was suddenly 100 and throwing everything off. 
* Conclusion

I think I've learned a lot from this project, despite it being relatively straightforward.  I'm sure there's a lot
on here that could be simplified or might not be written as correclty as it could be, but I feel like I've tackled 
some things in this project that I might not have been so familiar with before.  Strings in C aren't nearly as bad
as I expected them to be.  In fact, I'd even say doing this in C was easier than in Python.  When I first did it, 
I had to constantly convert between strings and lists, but now, there's not really any difference between a string, 
a list, a char or an int, they're all kind of part of the same thing.
